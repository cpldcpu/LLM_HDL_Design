# Experiment 1: Very Simple 16 bit CPU

After continuously running into the max token limitation when trying to design a cpu with 16 instructions, his is an attempt to design a very simple 16 bit CPU with only 8 instructions.

Steps:

1. Generate an instruction set architecture (ISA) description including instruction encoding
2. Use the output of prompt 1 to generated a verilog implementation.
3. Finally, write basic code examples.
4. Verification

I am using [phind](http://phind.com), which supposedly uses GPT4 as one underlying model. Also, Github Copilot is helping to write this document. Generally, instead of the dialogue mode I usually edited the prompt and started a new session to allow for consistency in the context. In most cases I had teh regenerate the response several times and picked the most suitable output.

## Step1:

*Prompt:*

```
Assume a 16-bit microprocessor in an accumulator based architecture. Register
are accumulator (16 bit), PC (12 bit) and carry flag. All instructions use
immediate addressing to a 12 bit memory address bus. The following instructions 
shall be implemented: LDA mem12, STA mem12, BCC mem12, BCS mem12,ADD mem12, 
SUB mem12, AND mem12, XOR mem12. The instruction are encoded into 16 bit words. 
List all instructions including encoding for each of them on a concise way. 

Use this template:

1. LDA mem12: Load accumulator with value from memory address mem12
   - Encoding: `0000 | mem12`
```

*Response:*

```
1. LDA mem12: Load accumulator with value from memory address mem12
   - Encoding: `0000 | mem12`
2. STA mem12: Store accumulator to memory address mem12
   - Encoding: `0001 | mem12`
3. BCC mem12: Branch to memory address mem12 if carry flag is not set
   - Encoding: `0010 | mem12`
4. BCS mem12: Branch to memory address mem12 if carry flag is set
   - Encoding: `0011 | mem12`
5. ADD mem12: Add value from memory address mem12 to accumulator
   - Encoding: `0100 | mem12`
6. SUB mem12: Subtract value from memory address mem12 from accumulator
   - Encoding: `0101 | mem12`
7. AND mem12: Logical AND value from memory address mem12 with accumulator
   - Encoding: `0110 | mem12`
8. XOR mem12: Logical XOR value from memory address mem12 with accumulator
   - Encoding: `0111 | mem12`
```

Generated by Github Copilot. Nicely enough it also generated a text template for the remaining steps.

## Step2:

*Prompt:*

(I had to append part of the first prompt, since i started a new chat session. I also added the instruction code listing as "code")

```
Assume a 16-bit microprocessor in an accumulator based architecture. Registers 
are accumulator (16 bit), PC (12 bit) and carry flag. All instructions use 
immediate addressing to a 12 bit memory address bus. Write a verilog implementation 
of the microprocessor with the given instruction set in a single module. Use as few 
lines of code as possible. inputs: clk,reset,memory_in output: memory_out,address, 
write_enable. Consider that each instruction is executed in one or more cycles, 
depending on whether an additional memory access is needed. Include a state machine 
to enable execution of multi-cycle instructions.
```

Copilot did not create meaningful code based on this prompt, so i used phind. 
The following code was generated:

*Response:*

```
Based on the given instruction set and the provided sources, you can implement the 
16-bit microprocessor in Verilog using a single module. The implementation will 
include a state machine to execute multi-cycle instructions. Here's an implementation 
that you can use as a starting point:

module microprocessor
   (input clk, 
    input reset, 
    input [15:0] memory_in, 
    output [15:0] memory_out, 
    output [11:0] address, 
    output write_enable);

  // Registers
  reg [15:0] accumulator;
  reg [11:0] pc;
  reg carry_flag;
  
  // State machine states
  typedef enum {FETCH, EXECUTE} state_t;
  state_t current_state, next_state;

  // Instruction decoding
  wire [3:0] opcode = memory_in[15:12];
  wire [11:0] mem12 = memory_in[11:0];

  // State machine
  always @(posedge clk or posedge reset) begin
    if (reset) begin
      current_state <= FETCH;
      pc <= 12'h0;
      accumulator <= 16'h0;
      carry_flag <= 1'b0;
    end else begin
      current_state <= next_state;
    end
  end

  // State machine transitions and instruction execution
  always @(*) begin
    next_state = current_state;
    case (current_state)
      FETCH: begin
        address = pc;
        write_enable = 1'b0;
        next_state = EXECUTE;
      end
      EXECUTE: begin
        case (opcode)
          4'b0000: begin // LDA mem12
            accumulator = memory_in;
            pc = pc + 1;
          end
          4'b0001: begin // STA mem12
            memory_out = accumulator;
            address = mem12;
            write_enable = 1'b1;
            pc = pc + 1;
          end
          4'b0010: begin // BCC mem12
            if (!carry_flag) pc = mem12;
            else pc = pc + 1;
          end
          4'b0011: begin // BCS mem12
            if (carry_flag) pc = mem12;
            else pc = pc + 1;
          end
          4'b0100: begin // ADD mem12
            accumulator = accumulator + memory_in;
            carry_flag = (accumulator + memory_in) > 16'hFFFF;
            pc = pc + 1;
          end
          4'b0101: begin // SUB mem12
            accumulator = accumulator - memory_in;
            carry_flag = (accumulator - memory_in) < 16'h0000;
            pc = pc + 1;
          end
          4'b0110: begin // AND mem12
            accumulator = accumulator & memory_in;
            pc = pc + 1;
          end
          4'b0111: begin // XOR mem12
            accumulator = accumulator ^ memory_in;
            pc = pc + 1;
          end
        endcase
      end
    endcase
  end
endmodule

This implementation uses a state machine with two states, FETCH and EXECUTE. 
The FETCH state reads the instruction from memory, and the EXECUTE state decodes 
and executes the instruction. The state machine transitions between these states 
to enable the execution of multi-cycle instructions. The microprocessor uses 
immediate addressing to access memory addresses, and all instructions are encoded 
with a 4-bit opcode and a 12-bit memory address.
```

This doesn't look too bad. The carry handling is somewhat dubious, I may have to fix that during verification.

## Step3:


*Prompt:*

```
Assume a 16-bit microprocessor in an accumulator based architecture. Register are 
accumulator (16 bit), PC (12 bit) and carry flag. All instructions use immediate 
addressing to a 12 bit memory address bus. The instruction set is given below.

Write a program that calculates the first 10 numbers in the fibonacci sequence. 
Constant should be predefined in the memory.
```

*Response:*

```
; Initialize memory locations
zero EQU 0x3000
one EQU 0x3002
ten EQU 0x3004
counter EQU 0x3006
fib0 EQU 0x3008
fib1 EQU 0x300A
fib_next EQU 0x300C

; Load constants
LDA zero     ; 0000 | zero
STA counter  ; 0001 | counter
LDA zero     ; 0000 | zero
STA fib0     ; 0001 | fib0
LDA one      ; 0000 | one
STA fib1     ; 0001 | fib1

; Calculate Fibonacci numbers
loop:
  LDA fib0   ; 0000 | fib0
  ADD fib1   ; 0100 | fib1
  STA fib_next ; 0001 | fib_next
  LDA fib1   ; 0000 | fib1
  STA fib0   ; 0001 | fib0
  LDA fib_next ; 0000 | fib_next
  STA fib1   ; 0001 | fib1
  LDA counter  ; 0000 | counter
  ADD one     ; 0100 | one
  STA counter  ; 0001 | counter
  SUB ten     ; 0101 | ten
  BCC loop    ; 0010 | loop
```

Looks about right. Interestingly, phind was not able to figure out using constants from memory, without me explicitly mentioning it, and tried to hallucinate an immediate load instruction.

## prime numbers

Trying to push things a bit further, I tried to ask it ot implement a prime number generator. 

*prompt*:

```
Assume a 16-bit microprocessor in an accumulator based architecture. Register are accumulator (16 bit),
PC (12 bit) and carry flag. All instructions use immediate addressing to a 12 bit memory address bus. 
The instruction set is given below.

Write a program that determines if a number is prime. The number to test is given in the memory location 
"input". The program shall write 1 to the location "isprime" if the input number is prime and zero otherwise.
constants 0,1,2 are given in memory locations zero, one, two. 

Consider that this processor has no division instruction.
```

It seems that this is pushing things a bit too far, as additional instructions were hallucinated (DIV) or instructions were plainly used incorrectly.




