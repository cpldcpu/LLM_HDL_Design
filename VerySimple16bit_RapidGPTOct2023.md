# Another attempt at a 16-bit CPU, this time with RapidGPT

I was made aware of RapidGPT, a product of [Primis AI](https://primis.ai/) that is a chat based assistant specifically for hardware description languages. I will subject it to the same zero or few-short approach I used in my other experiments. I am well aware that this is not the best way to get the most out of currently available LLM, but it is the way of working that we would anticapte from an AI assistant at some point.

**Verdict**

It is less erratic than Copilot with Verilog, but not obviously better than GPT4. There are some neat ideas to handle conversational scope in the plugin, but copilot does already have the same implemented in a more universial way (you can simply select code of interest in the editor).

## The CPU

### Prompt to generate ISA

```
Assume a 16-bit microprocessor in an accumulator based architecture. Register
are accumulator (16 bit), PC (12 bit) and carry flag. All instructions use
immediate addressing to a 12 bit memory address bus. The following instructions 
shall be implemented: LDA mem12, STA mem12, BCC mem12, BCS mem12,ADD mem12, 
SUB mem12, AND mem12, XOR mem12. The instruction are encoded into 16 bit words. 
List all instructions including encoding for each of them on a concise way. 

Use this template:

1. LDA mem12: Load accumulator with value from memory address mem12
   - Encoding: `0000 | mem12`
```

### Output (generated by RapidGPT)

```
Sure! Here are the instructions and their encodings for the 16-bit microprocessor in an accumulator based architecture:

1. LDA mem12: Load accumulator with value from memory address mem12
- Encoding: 0000 | mem12

2. STA mem12: Store the value in the accumulator to memory address mem12
- Encoding: 0001 | mem12

3. BCC mem12: Branch to memory address mem12 if carry flag is clear (0)
- Encoding: 0010 | mem12

4. BCS mem12: Branch to memory address mem12 if carry flag is set (1)
- Encoding: 0011 | mem12

5. ADD mem12: Add the value at memory address mem12 to the accumulator
- Encoding: 0100 | mem12

6. SUB mem12: Subtract the value at memory address mem12 from the accumulator
- Encoding: 0101 | mem12

7. AND mem12: Perform a bitwise AND operation between the value at memory address mem12 and the accumulator
- Encoding: 0110 | mem12

8. XOR mem12: Perform a bitwise XOR operation between the value at memory address mem12 and the accumulator
- Encoding: 0111 | mem12

Please note that mem12 represents the 12-bit memory address.
```


### Prompt to generate Python emulator

```
Implement a cpu emulator in a standalone python program that is able to emulate the cpu with the marked instruction set architecture. The status of the registers and executed instruction should be printed to the console for each cycle. The emulation should automatically stop after 20 cycles. The program that is to be executed is to be loaded from a text file that contains the code memory in binary representation. One line per instruction. The file name is given as an argument to the python program.
```

RapidGPT only provided a code outline for the emulator, but it looked generally sensible. I did not iterate on this step as the HDL generation was more interesting to me.

### Output

```python

# Read the binary file containing the code memory instructions
with open(file_name, 'rb') as file:
    code_memory = file.readlines()

# Initialize the CPU state
accumulator = 0
pc = 0
carry_flag = 0

# Emulation loop
for cycle in range(20):
    # Fetch instruction from memory
    instruction = int(code_memory[pc], 2)

    # Decode the instruction
    opcode = (instruction >> 12) & 0xF
    mem_address = instruction & 0xFFF

    # Execute the instruction
    if opcode == 0:
        # LDA mem12: Load accumulator with value from memory address mem12
        accumulator = int(code_memory[mem_address], 2)
    elif opcode == 1:
        # STA mem12: Store the value in the accumulator to memory address mem12
        code_memory[mem_address] = bin(accumulator)[2:].zfill(16)
    elif opcode == 2:
        # BCC mem12: Branch to memory address mem12 if carry flag is clear (0)
        if carry_flag == 0:
            pc = mem_address
    elif opcode == 3:
        # BCS mem12: Branch to memory address mem12 if carry flag is set (1)
        if carry_flag == 1:
            pc = mem_address
    elif opcode == 4:
        # ADD mem12: Add the value at memory address mem12 to the accumulator
        accumulator += int(code_memory[mem_address], 2)
    elif opcode == 5:
        # SUB mem12: Subtract the value at memory address mem12 from the accumulator
        accumulator -= int(code_memory[mem_address], 2)
    elif opcode == 6:
        # AND mem12: Perform a bitwise AND operation between the value at memory address mem12 and the accumulator
        accumulator &= int(code_memory[mem_address], 2)
    elif opcode == 7:
        # XOR mem12: Perform a bitwise XOR operation between the value at memory address mem12 and the accumulator
        accumulator ^= int(code_memory[mem_address], 2)

    # Update the program counter
    pc += 1

    # Print CPU state and executed instruction
    print(f"Cycle {cycle+1}:")
    print(f"Accumulator: {accumulator}")
    print(f"PC: {pc}")
    print(f"Carry Flag: {carry_flag}")
    print(f"Executed Instruction: {bin(instruction)[2:].zfill(16)}")
    print()

    # Check if program counter exceeds code memory size
    if pc >= len(code_memory):
        break
```

### Test program

RapidGPT did surprisingly well on this part. It did hower hallicinate a LDA immediate instruction (which should be in the ISA, but was not specified). The code looks sensible, but I did not test it. The translation to binary is a mess, but this is an obvious weakness of LLMs.

```
please write a test program that calculates the fibonacci series. It shall use memory locations 128 and up for temporary storage. Use only the instructions in the marked ISA. The program should start by initializing the memory locations with constants. The program runs indefinitely.

To make sure the program is correct, work step by step by first outputting the assembled mnemonics and then converting them to the target binary file in text format compatible with the emualtor. outline your thoughts in each step. Make sure to add comments with # to the binary file for the emualator.
```

### output

```python
# Initialize the memory locations 128 and up with constants
# LDA mem12: Load accumulator with value from memory address mem12
# STA mem12: Store the value in the accumulator to memory address mem12

# Store the initial values of 0 and 1 at memory locations 128 and 129
# LDA 0
# STA 128
# LDA 1
# STA 129

# Use a loop to calculate the Fibonacci series indefinitely
# ADD mem12: Add the value at memory address mem12 to the accumulator

# Set the program counter (PC) to the start of the loop
# Loop:
#   LDA 128
#   ADD 129
#   STA 130
#   LDA 129
#   STA 128
#   LDA 130
#   STA 129
#   BCC Loop

# Output the assembled mnemonics and convert them to the target binary file
# Add comments in the binary file using "#"

# Assembled mnemonics:
"""
LDA 0
STA 128
LDA 1
STA 129
Loop:
LDA 128
ADD 129
STA 130
LDA 129
STA 128
LDA 130
STA 129
BCC Loop
"""

# Binary file:
"""
0000 0000 0000 0000  # LDA 0
0001 1000 0000 0000  # STA 128
0000 0000 0000 0001  # LDA 1
0001 1001 0000 0000  # STA 129
0000 1000 1000 0000  # Loop: LDA 128
0100 1001 1000 0000  # ADD 129
0001 0010 1000 0010  # STA 130
0000 1001 1000 0001  # LDA 129
0001 1000 1000 0000  # STA 128
0000 1001 1000 0010  # LDA 130
0001 1001 1000 0001  # STA 129
0010 0000 0000 1000  # BCC Loop
"""

# Save the binary file to a text file compatible with the emulator
# Write the binary instructions as text to a file (e.g., "fibonacci.txt")
# Each line in the file corresponds to one instruction in binary format
# Add "#" comments to the file for the emulator

# fibonacci.txt:
"""
0000000000000000  # LDA 0
0001100000000000  # STA 128
0000000000000001  # LDA 1
0001100100000000  # STA 129
0000100010000000  # Loop: LDA 128
0100100110000000  # ADD 129
0001001010000010  # STA 130
0000100110000001  # LDA 129
0001100010000000  # STA 128
0000100110000010  # LDA 130
0001100110000001  # STA 129
0010000000001000  # BCC Loop
"""
```

## Verilog implementation (RapidGPT)

To be consistent with the other experiments, I reset the conversation history and started with the prompt below. 

```
The table below shows the instruction set architecture of a simple 16 bit cpu. Registers are Accumulator (16 bit), PC (12 bit) and carry flag.

Write a single verilog module that implements this architecture. Inputs shall be: clk,reset, datain (16 bit). Output: adrout(12 bit), dataout (16 bit), write enable. 

This is a von-neumann computer with shared Memory. The memory is implemented externally as a standard parallel SRAM and is accessed via the modules interface. You may have to implement a state machine to handle multi-cycle instructions that access the memory.


1. LDA mem12: Load accumulator with value from memory address mem12
    - Encoding: `0000 | mem12`
2. STA mem12: Store accumulator value to memory address mem12
    - Encoding: `0001 | mem12`
3. BCC mem12: Branch to memory address mem12 if carry flag is clear
    - Encoding: `0010 | mem12`
4. BCS mem12: Branch to memory address mem12 if carry flag is set
    - Encoding: `0011 | mem12`
5. ADD mem12: Add value from memory address mem12 to accumulator
    - Encoding: `0100 | mem12`
6. SUB mem12: Subtract value from memory address mem12 from accumulator
    - Encoding: `0101 | mem12`
7. AND mem12: Bitwise AND value from memory address mem12 with accumulator
    - Encoding: `0110 | mem12`
8. XOR mem12: Bitwise XOR value from memory address mem12 with accumulator
    - Encoding: `0111 | mem12`
9. LDI imm12: Load accumulator with immediate 12-bit value imm12
    - Encoding: `1000 | imm12`
```

## Output

RapidGPT consistently provided full Verilog implementations, much more reliability than Copilot but not better than GPT4. However, just as with the other tools, there are still plenty of logical errors and inconsistencies in the generated code, that could theoritically be fixed by iterative prompting. One very strange issue was that RadidGPT would just not understand that the memory is not to be implemented in the verilog module. 

Example output (one of ~10). Note the lack of proper state implementation and the inclusion of memory in the module. It also failed to handle carry correctly, something that GPT4 managed to do.

```verilog

module SimpleCPU (
  input wire clk,
  input wire reset,
  input wire [15:0] datain,
  output wire [11:0] adrout,
  output wire [15:0] dataout,
  output wire write_enable
);

  // Define registers
  reg [15:0] accumulator;
  reg [11:0] program_counter;
  reg carry_flag;

  // Define memory
  reg [15:0] memory [0:4095];

  // Define control signals
  reg [3:0] opcode;
  reg [11:0] operand;
  reg [15:0] immediate;

  // Define internal signals
  wire [15:0] alu_result;
  wire [15:0] memory_data;
  wire carry_out;
  wire zero_flag;

  // State machine states
  localparam IDLE = 2'b00;
  localparam FETCH = 2'b01;
  localparam EXECUTE = 2'b10;

  // Define state register and next state logic
  reg [1:0] state;
  always @(posedge clk, posedge reset)
  begin
    if (reset)
      state <= IDLE;
    else
      case (state)
        IDLE: state <= FETCH;
        FETCH: state <= EXECUTE;
        EXECUTE: state <= FETCH;
      endcase
  end

  // Fetch stage
  always @(posedge clk)
  begin
    if (state == FETCH)
    begin
      program_counter <= program_counter + 1;
      opcode <= memory[program_counter][15:12];
      operand <= memory[program_counter][11:0];
      immediate <= operand;
    end
  end

  // Execute stage
  always @(posedge clk)
  begin
    if (state == EXECUTE)
    begin
      case (opcode)
        4'b0000: // LDA
          begin
            accumulator <= memory[operand];
          end
        4'b0001: // STA
          begin
            memory[operand] <= accumulator;
          end
        4'b0010: // BCC
          begin
            if (!carry_flag)
              program_counter <= operand;
          end
        4'b0011: // BCS
          begin
            if (carry_flag)
              program_counter <= operand;
          end
        4'b0100: // ADD
          begin
            alu_result <= accumulator + memory[operand];
            carry_flag <= alu_result[16];
            accumulator <= alu_result[15:0];
          end
        4'b0101: // SUB
          begin
            alu_result <= accumulator - memory[operand];
            carry_flag <= alu_result[16];
            accumulator <= alu_result[15:0];
          end
        4'b0110: // AND
          begin
            accumulator <= accumulator & memory[operand];
          end
        4'b0111: // XOR
          begin
            accumulator <= accumulator ^ memory[operand];
          end
        4'b1000: // LDI
          begin
            accumulator <= immediate;
          end
      endcase
    end
  end

  // Memory interface
  assign adrout = program_counter;
  assign dataout = memory[program_counter];
  assign write_enable = (opcode == 4'b0001);

endmodule
```