# Another attempt at a 16-bit CPU

Now its October 2023 and many new and updated AI tools became available. Let's give the very simple 16-bit CPU another try.I am planning to use Copilot mostly (with the chat mode), but maybe also GPT4.

**Verdict**

It's much closer now, but HDLs are still not a strong side of the LLMs that are available for code assist.

## The CPU

We'll just use the same prompt as last time

### Prompt to generate ISA

```
Assume a 16-bit microprocessor in an accumulator based architecture. Register
are accumulator (16 bit), PC (12 bit) and carry flag. All instructions use
immediate addressing to a 12 bit memory address bus. The following instructions 
shall be implemented: LDA mem12, STA mem12, BCC mem12, BCS mem12,ADD mem12, 
SUB mem12, AND mem12, XOR mem12. The instruction are encoded into 16 bit words. 
List all instructions including encoding for each of them on a concise way. 

Use this template:

1. LDA mem12: Load accumulator with value from memory address mem12
   - Encoding: `0000 | mem12`
```

### Output (generated by Copilot in markdown)

Here are all the instructions and their encodings:

1. LDA mem12: Load accumulator with value from memory address mem12
    - Encoding: `0000 | mem12`
2. STA mem12: Store accumulator value to memory address mem12
    - Encoding: `0001 | mem12`
3. BCC mem12: Branch to memory address mem12 if carry flag is clear
    - Encoding: `0010 | mem12`
4. BCS mem12: Branch to memory address mem12 if carry flag is set
    - Encoding: `0011 | mem12`
5. ADD mem12: Add value from memory address mem12 to accumulator
    - Encoding: `0100 | mem12`
6. SUB mem12: Subtract value from memory address mem12 from accumulator
    - Encoding: `0101 | mem12`
7. AND mem12: Bitwise AND value from memory address mem12 with accumulator
    - Encoding: `0110 | mem12`
8. XOR mem12: Bitwise XOR value from memory address mem12 with accumulator
    - Encoding: `0111 | mem12`


### Prompt to generate Python emulator

```
Implement a cpu emulator in a standalone python program that is able to emulate the cpu with the marked instruction set architecture. The status of the registers and executed instruction should be printed to the console for each cycle. The emulation should automatically stop after 20 cycles. The program that is to be executed is to be loaded from a text file that contains the code memory in binary representation. One line per instruction. The file name is given as an argument to the python program.
```

### Output

```python
# Python CPU emulator for VerySimple16bit_Oct2023 instruction set architecture

import sys

# Define CPU class
class CPU:
    def __init__(self):
        self.registers = [0] * 16
        self.memory = [0] * 65536
        self.pc = 0
        self.carry_flag = 0

    def load_program(self, filename):
        with open(filename, 'r') as f:
            for i, line in enumerate(f):
                self.memory[i] = int(line.strip(), 2)

    def execute_instruction(self, instruction):
        opcode = instruction >> 12
        operand = instruction & 0xfff

        if opcode == 0:
            self.registers[0] = self.memory[operand]
        elif opcode == 1:
            self.memory[operand] = self.registers[0]
        elif opcode == 2:
            if self.carry_flag == 0:
                self.pc = operand
        elif opcode == 3:
            if self.carry_flag == 1:
                self.pc = operand
        elif opcode == 4:
            self.registers[0] += self.memory[operand]
            if self.registers[0] > 0xffff:
                self.registers[0] &= 0xffff
                self.carry_flag = 1
            else:
                self.carry_flag = 0
        elif opcode == 5:
            self.registers[0] -= self.memory[operand]
            if self.registers[0] < 0:
                self.registers[0] &= 0xffff
                self.carry_flag = 1
            else:
                self.carry_flag = 0
        elif opcode == 6:
            self.registers[0] &= self.memory[operand]
        elif opcode == 7:
            self.registers[0] ^= self.memory[operand]

    def run(self, cycles=20):
        for i in range(cycles):
            instruction = self.memory[self.pc]
            self.execute_instruction(instruction)
            print(f"Cycle {i+1}: PC={self.pc}, Reg={self.registers}, Carry={self.carry_flag}, Instruction={instruction:04x}")
            self.pc += 1

# Main program
if __name__ == '__main__':
    if len(sys.argv) != 2:
        print("Usage: python cpu_emulator.py <filename>")
        sys.exit(1)

    cpu = CPU()
    cpu.load_program(sys.argv[1])
    cpu.run()
```

### Adding load immediate instruction

```
ok, I notice I forgot an instruction to load immediates. can you propose one and output the ISA in the same format as used before?
```

### Output (generated by Copilot in markdown)

Here are all the instructions and their encodings:

1. LDA mem12: Load accumulator with value from memory address mem12
    - Encoding: `0000 | mem12`
2. STA mem12: Store accumulator value to memory address mem12
    - Encoding: `0001 | mem12`
3. BCC mem12: Branch to memory address mem12 if carry flag is clear
    - Encoding: `0010 | mem12`
4. BCS mem12: Branch to memory address mem12 if carry flag is set
    - Encoding: `0011 | mem12`
5. ADD mem12: Add value from memory address mem12 to accumulator
    - Encoding: `0100 | mem12`
6. SUB mem12: Subtract value from memory address mem12 from accumulator
    - Encoding: `0101 | mem12`
7. AND mem12: Bitwise AND value from memory address mem12 with accumulator
    - Encoding: `0110 | mem12`
8. XOR mem12: Bitwise XOR value from memory address mem12 with accumulator
    - Encoding: `0111 | mem12`
9. LDI imm12: Load accumulator with immediate 12-bit value imm12
    - Encoding: `1000 | imm12`

### Update Emulator

```
update the emulator as well? please also add code that strups comments while loading the program code. Everything after a # should be discarded
```
### Output

```python
# Python CPU emulator for VerySimple16bit_Oct2023 instruction set architecture

import sys

# Define CPU class
class CPU:
    def __init__(self):
        self.registers = [0] * 16
        self.memory = [0] * 65536
        self.pc = 0
        self.carry_flag = 0

    def load_program(self, filename):
        with open(filename, 'r') as f:
            for i, line in enumerate(f):
                # Strip comments
                line = line.split('#')[0].strip()
                if not line:
                    continue
                self.memory[i] = int(line, 2)

    def execute_instruction(self, instruction):
        opcode = instruction >> 12
        operand = instruction & 0xfff

        if opcode == 0:
            self.registers[0] = self.memory[operand]
        elif opcode == 1:
            self.memory[operand] = self.registers[0]
        elif opcode == 2:
            if self.carry_flag == 0:
                self.pc = operand
        elif opcode == 3:
            if self.carry_flag == 1:
                self.pc = operand
        elif opcode == 4:
            self.registers[0] += self.memory[operand]
            if self.registers[0] > 0xffff:
                self.registers[0] &= 0xffff
                self.carry_flag = 1
            else:
                self.carry_flag = 0
        elif opcode == 5:
            self.registers[0] -= self.memory[operand]
            if self.registers[0] < 0:
                self.registers[0] &= 0xffff
                self.carry_flag = 1
            else:
                self.carry_flag = 0
        elif opcode == 6:
            self.registers[0] &= self.memory[operand]
        elif opcode == 7:
            self.registers[0] ^= self.memory[operand]
        elif opcode == 8:
            self.registers[0] = operand

    def run(self, cycles=20):
        for i in range(cycles):
            instruction = self.memory[self.pc]
            self.execute_instruction(instruction)
            print(f"Cycle {i+1}: PC={self.pc}, Reg={self.registers}, Carry={self.carry_flag}, Instruction={instruction:04x}")
            self.pc += 1

# Main program
if __name__ == '__main__':
    if len(sys.argv) != 2:
        print("Usage: python cpu_emulator.py <filename>")
        sys.exit(1)

    cpu = CPU()
    cpu.load_program(sys.argv[1])
    cpu.run()
```

### Test program

This part did not work as well. I changed the prompt several times to improve the output. There where often logical errors in the test program, hallucinated instructions and encoding errors. In any case, here is the last output.

```
please write a test program that calculates the fibonacci series. It shall use memory locations 128 and up for temporary storage. Use only the instructions in the marked ISA. The program should start by initializing the memory locations with constants. The program runs indefinitely.

To make sure the program is correct, work step by step by first outputting the assembled mnemonics and then converting them to the target binary file in text format compatible with the emualtor. outline your thoughts in each step. Make sure to add comments with # to the binary file for the emualator.
```

### output

```python
# Initialize memory locations 128 and 129 with the first two Fibonacci numbers
LDI 0x00 # Load 0 into accumulator
STA 0x80 # Store 0 at memory location 128
LDI 0x01 # Load 1 into accumulator
STA 0x81 # Store 1 at memory location 129

# Calculate the next Fibonacci numbers indefinitely
LOOP:
    # Load the two previous Fibonacci numbers into registers 1 and 2
    LDA 0x80 # Load value at memory location 128 into accumulator
    STA 0x82 # Store value in register 2
    LDA 0x81 # Load value at memory location 129 into accumulator
    STA 0x83 # Store value in register 3

    # Calculate the next Fibonacci number and store it in memory
    ADD 0x82 # Add register 2 to accumulator
    STA 0x84 # Store result at memory location 130

    # Shift the previous Fibonacci numbers down one memory location
    LDA 0x83 # Load value from register 3 into accumulator
    STA 0x80 # Store value at memory location 128
    LDA 0x84 # Load value from memory location 130 into accumulator
    STA 0x81 # Store value at memory location 129

    # Print the current Fibonacci number
    LDA 0x84 # Load value from memory location 130 into accumulator
    OUT      # Output value to console

    # Jump back to the beginning of the loop
    JMP LOOP # Jump to label LOOP
```

binary:

```
1000000000000000 # LDI 0x00
0001000000000000 # STA 0x80
1000000000000001 # LDI 0x01
0001000000000001 # STA 0x81
0000000001000000 # LDA 0x80
0001000000000010 # STA 0x82
0000000001000001 # LDA 0x81
0001000000000011 # STA 0x83
0100000000000010 # ADD 0x82
0001000000000100 # STA 0x84
0000000001000011 # LDA 0x83
0001000000000000 # STA 0x80
0000000001000100 # LDA 0x84
0001000000000001 # STA 0x81
0000000001000100 # LDA 0x84
1110000000000000 # OUT
0010000000000000 # JMP LOOP
```

## Verilog implementation (copilot)

This is where things turned a bit weird with copilot. I was able to produce verilog output with very simple prompts, but when I added more detailed instructions I always got "Sorry, but I can only assist with programming related questions". It appears that Github knows that Verilog support is flaky and tried to discourage people from using copilot for it.

Example output below, which is passable but a bit buggy.

Prompt
```
verilog program
```    

Output

```verilog
module memory(
    input [15:0] address,
    input [15:0] data_in,
    input write_enable,
    output [15:0] data_out
);

reg [15:0] mem[0:65535];

assign data_out = mem[address];

always @(posedge write_enable)
    mem[address] <= data_in;

endmodule

module cpu(
    input clk,
    input reset,
    input [15:0] instruction_address,
    output reg [15:0] accumulator,
    output reg carry_flag
);

reg [15:0] instruction;
wire [3:0] opcode;
wire [11:0] operand;

memory mem(
    .address(instruction_address),
    .data_in(accumulator),
    .write_enable(0),
    .data_out(instruction)
);

assign opcode = instruction[15:12];
assign operand = instruction[11:0];

always @(posedge clk) begin
    if (reset) begin
        accumulator <= 0;
        carry_flag <= 0;
    end else begin
        case (opcode)
            4'b0000: accumulator <= mem.data_out;
            4'b0001: mem.write_enable <= 1;
                      mem.data_in <= accumulator;
            4'b0010: if (!carry_flag) instruction_address <= operand;
            4'b0011: if (carry_flag) instruction_address <= operand;
            4'b0100: accumulator <= accumulator + mem.data_out;
            4'b0101: accumulator <= accumulator - mem.data_out;
            4'b0110: accumulator <= accumulator & mem.data_out;
            4'b0111: accumulator <= accumulator ^ mem.data_out;
        endcase

        carry_flag <= (accumulator[15] == 1);
    end
end

endmodule
```

## Verilog implementation (GPT4)

Using GPT4 (code interpreter, September 25 version) yielded much better results. Look at how it handles the carry flag, pretty cool. But there are still a lot of inconsistencies in handling data between states. Generally, concurrency is not handled well.


```
The table below shows the instruction set architecture of a simple 16 bit cpu. Registers are Accumulator (16 bit), PC (12 bit) and carry flag.

Write a single verilog module that implements this architecture. Inputs shall be: clk,reset, datain (16 bit). Output: adrout(12 bit), dataout (16 bit), write enable. 

Memory is external and you may have to implement a state machine to handle multi-cycle instructions that access the memory.


1. LDA mem12: Load accumulator with value from memory address mem12
    - Encoding: `0000 | mem12`
2. STA mem12: Store accumulator value to memory address mem12
    - Encoding: `0001 | mem12`
3. BCC mem12: Branch to memory address mem12 if carry flag is clear
    - Encoding: `0010 | mem12`
4. BCS mem12: Branch to memory address mem12 if carry flag is set
    - Encoding: `0011 | mem12`
5. ADD mem12: Add value from memory address mem12 to accumulator
    - Encoding: `0100 | mem12`
6. SUB mem12: Subtract value from memory address mem12 from accumulator
    - Encoding: `0101 | mem12`
7. AND mem12: Bitwise AND value from memory address mem12 with accumulator
    - Encoding: `0110 | mem12`
8. XOR mem12: Bitwise XOR value from memory address mem12 with accumulator
    - Encoding: `0111 | mem12`
9. LDI imm12: Load accumulator with immediate 12-bit value imm12
    - Encoding: `1000 | imm12`
```

Output

```verilog
module SimpleCPU (
    input clk,
    input reset,
    input [15:0] datain,
    output reg [11:0] adrout,
    output reg [15:0] dataout,
    output reg write_enable
);

// Define states
typedef enum {
    FETCH,
    EXECUTE,
    MEMREAD,
    MEMWRITE
} State;

reg [1:0] currentState, nextState;

// Registers
reg [15:0] ACC;
reg [11:0] PC;
reg carry;
reg [3:0] opcode; // Store the opcode

// State machine logic
always @(posedge clk or posedge reset) begin
    if (reset) begin
        currentState <= FETCH;
        PC <= 12'b0;
        ACC <= 16'b0;
        carry <= 0;
        opcode <= 4'b0000;
    end else begin
        currentState <= nextState;
    end
end

// Main state machine
always @(currentState or datain or ACC or PC or carry or opcode) begin
    nextState = currentState;
    write_enable = 0; // Default

    case (currentState)
        FETCH: begin
            adrout = PC;
            opcode = datain[15:12];
            PC = PC + 1;
            if(opcode == 4'b0001) 
                nextState = MEMWRITE; // STA
            else
                nextState = MEMREAD;
        end

        MEMREAD: begin
            adrout = datain[11:0];
            case (opcode)
                4'b0000: ACC = datain; // LDA
                4'b0100: begin // ADD
                    ACC = ACC + datain;
                    if (ACC + datain < ACC) carry = 1; else carry = 0;
                end
                4'b0101: begin // SUB
                    if (ACC < datain) carry = 1; else carry = 0;
                    ACC = ACC - datain;
                end
                4'b0110: ACC = ACC & datain; // AND
                4'b0111: ACC = ACC ^ datain; // XOR
                4'b0010: if (!carry) PC = datain[11:0]; // BCC
                4'b0011: if (carry) PC = datain[11:0]; // BCS
                4'b1000: ACC = datain[11:0]; // LDI
            endcase
            nextState = FETCH;
        end

        MEMWRITE: begin
            adrout = datain[11:0];
            dataout = ACC;
            write_enable = 1;
            nextState = FETCH;
        end
    endcase
end

endmodule

```
