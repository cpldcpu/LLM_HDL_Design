# Experiment 1: Simple 16 bit CPU

This is an attempt to design a simple 16 bit CPU using a large language model (LLM). I will use some manually prompted chain-of-thought:

1. Generate an instruction set architecture (ISA) description including instruction encoding
2. Use the output of prompt 1 to generated a verilog implementation.
3. Finally, write basic code examples.

I am using [phind](http://phind.com), which supposedly uses GPT4 as one underlying model. Also, Github Copilot is helping to write this document.

## Step1:

*Prompt:*

```
Assume a 16-bit RISC microprocessor with 16 data registers R0-R15, C and Z flag. The following 
instructions shall be implemented: AND, XOR, OR, ADC, ADD, SUB (rx,ry,rz), LSL #imm4,Rx,Ry , 
LSR #imm4, Rx, Ry , LDI Rx,#simm8, LDIH Rx,#imm8, LD Rx, #simm4(Ry), ST #simm4(Rx), Ry, JMP #imm12, 
BCC #imm12, BCS #imm12, BZS #imm12. The PC is 12 bit, the other registers are 16 bit. The instructions 
are encoded into 16 bit words. List all instructions including encoding for each of them on a concise way. 

Use this template:
1. AND rx, ry, rz: bitwise AND operation
   - Encoding: `0000 | rx | ry | rz`
```

*Response:*

This one was actually generated by github copilot, but phind will generate a similar response.

```The instruction set is:
1. AND rx, ry, rz: bitwise AND operation
   - Encoding: `0000 | rx | ry | rz`
2. XOR rx, ry, rz: bitwise XOR operation
   - Encoding: `0001 | rx | ry | rz`
3. OR rx, ry, rz: bitwise OR operation
   - Encoding: `0010 | rx | ry | rz`
4. ADC rx, ry, rz: bitwise ADD with carry
   - Encoding: `0011 | rx | ry | rz`
5. ADD rx, ry, rz: bitwise ADD
   - Encoding: `0100 | rx | ry | rz`
6. SUB rx, ry, rz: bitwise SUB
   - Encoding: `0101 | rx | ry | rz`
7. LSL #imm4, Rx, Ry: left shift by imm4
   - Encoding: `0110 | Rx | Ry | imm4`
8. LSR #imm4, Rx, Ry: right shift by imm4
   - Encoding: `0111 | Rx | Ry | imm4`
9. LDI Rx, #simm8: load immediate 8 bits
   - Encoding: `1000 | Rx | simm8`
10. LDIH Rx, #imm8: load immediate high 8 bits
   - Encoding: `1001 | Rx | imm8`
11. LD Rx, #simm4(Ry): load word from memory
   - Encoding: `1010 | Rx | Ry | simm4`
12. ST #simm4(Rx), Ry: store word to memory
   - Encoding: `1011 | Rx | Ry | simm4`
13. JMP #imm12: jump to address
   - Encoding: `1100 | imm12`
14. BCC #imm12: branch if carry is clear
   - Encoding: `1101 | imm12`
15. BCS #imm12: branch if carry is set
   - Encoding: `1110 | imm12`
16. BZS #imm12: branch if zero flag is set
   - Encoding: `1111 | imm12`
```

Very nice, this is a good starting point. I will use this to generate a Verilog implementation. The LLM correctly identified the meaning of even more exotic instructions like 'LDIH'

## Step 2

*Prompt:*

```
Write a verilog implementation of the microprocessor with the given instruction set in a single 
module. Use as few lines of code as possible. inputs: clk,reset,memory_in output: memory_out,address, 
write_enable. Consider that each instruction is executed in one or more cycles, depending on whether 
an additional memory access is needed. Include a state machine to enable execution of multi-cycle 
instructions.
```

The main issue I ran into was that the generated Verilog code turned out to be too long for the token window size of the LLM. Usually the LLM then started to skip parts of the code, suggesting to fill those in later. 

*Response:*

```
Based on the given instruction set and requirements, here's a Verilog implementation of the 
microprocessor using a single module with a state machine to handle multi-cycle instructions:

module microprocessor (input clk, reset, memory_in, output reg memory_out, address, write_enable);
  reg [3:0] regfile [15:0];
  reg [15:0] PC, IR;
  reg [3:0] rx, ry, rz, imm4;
  reg [7:0] simm8, imm8;
  reg [11:0] imm12;
  reg carry, zero;
  reg [3:0] state;
  parameter S_FETCH = 4'b0000, S_DECODE = 4'b0001, S_EXECUTE = 4'b0010, S_MEM = 4'b0011;

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      state <= S_FETCH;
    end else begin
      case (state)
        S_FETCH: begin
          PC <= PC + 1;
          IR <= memory_in;
          state <= S_DECODE;
        end
        S_DECODE: begin
          rx = IR[11:8];
          ry = IR[7:4];
          rz = IR[3:0];
          imm4 = IR[3:0];
          simm8 = {IR[7], IR[7:0]};
          imm8 = IR[7:0];
          imm12 = IR[11:0];
          state <= S_EXECUTE;
        end
        S_EXECUTE: begin
          case (IR[15:12])
            4'b0000: regfile[rz] <= regfile[rx] & regfile[ry];
            4'b0001: regfile[rz] <= regfile[rx] ^ regfile[ry];
            4'b0010: regfile[rz] <= regfile[rx] | regfile[ry];
            4'b0011: begin
              {carry, regfile[rz]} <= regfile[rx] + regfile[ry] + carry;
            end
            4'b0100: regfile[rz] <= regfile[rx] + regfile[ry];
            4'b0101: regfile[rz] <= regfile[rx] - regfile[ry];
            4'b0110: regfile[ry] <= regfile[rx] << imm4;
            4'b0111: regfile[ry] <= regfile[rx] >> imm4;
            4'b1000: regfile[rx] <= simm8;
            4'b1001: regfile[rx] <= {imm8, regfile[rx][7:0]};
            4'b1010: begin
              address <= regfile[ry] + imm4;
              state <= S_MEM;
            end
            4'b1011: begin
              address <= regfile[rx] + imm4;
              memory_out <= regfile[ry];
              write_enable <= 1;
              state <= S_MEM;
            end
            4'b1100: PC <= imm12;
            4'b1101: if (!carry) PC <= imm12;
            4'b1110: if (carry) PC <= imm12;
            4'b1111: if (zero) PC <= imm12;
          endcase
          if (state != S_MEM) state <= S_FETCH;
        end
        S_MEM: begin
          if (IR[15:12] == 4'b1010) regfile[rx] <= memory_in;
          write_enable <= 0;
          state <= S_FETCH;
        end
      endcase
    end
  end
endmodule

In this implementation, we use a state machine with four states: `S_FETCH`, `S_DECODE`, 
`S_EXECUTE`, and `S_MEM`. The state machine transitions between these states to handle 
multi-cycle instructions, such as `LD` and `ST`, which require additional memory access.

The module takes `clk`, `reset`, and `memory_in` as inputs, and outputs `memory_out`, 
`address`, and `write_enable`. The register file is represented by a 4-bit wide array 
of 16 registers, and the instruction set is encoded using a 4-bit opcode followed by 
register indices or immediate values, as specified in the given instruction set.

The state machine transitions through the fetch, decode, and execute states for most 
instructions, with memory access handled in the `S_MEM` state when necessary. The `case`
```

This response does not look too bad, but there are some bugs:
- LDI, LDIH is not handled correctly
- The carry flag is derived from a non-existing 17th bit of the accumulator

Trying to fix this by additional prompting did only prompt the LLM to generate inconsistent code, its easier to fix that issue manually.

